// Generated by CoffeeScript 1.6.1
(function() {

  describe('Item', function() {
    it('should not create an item from corrupt JSON string', function() {
      return expect(Item.createFromJSON('1-abcdef01234', '{')).toBeNull();
    });
    it('should create an item from correct JSON string', function() {
      var data, i;
      data = '{"revisions":[],"creation":1382207794.2,"resolution":0,' + '"modification":1382207794,"category":"Some category",' + '"text":"Some text","position":1.2}';
      i = Item.createFromJSON('someid-1-abcdef01234', data);
      expect(i.getID()).toEqual('someid');
      expect(i.revision).toMatch(/^1-abcdef01234$/);
      expect(i.getCreated()).toEqual(1382207794.2);
      expect(i.isResolved()).toEqual(false);
      expect(i.getCategory()).toEqual('Some category');
      expect(i.getText()).toEqual('Some text');
      return expect(i.getPosition()).toEqual(1.2);
    });
    it('should create a new item', function() {
      var category, i, text;
      text = 'Example Text';
      category = 'Example Category';
      i = Item.createNew(text, category);
      expect(i.getID().length).toBeGreaterThan(0);
      expect(i.getCreated()).toBeGreaterThan(0);
      expect(i.getResolved()).toEqual(0);
      expect(i.getText()).toEqual(text);
      expect(i.getCategory()).toEqual(category);
      return expect(i.revision).toMatch(/^1-/);
    });
    it('should increase revision numbers on change and store revisions', function() {
      var firstRevision, i, secondRevision, thirdRevision;
      i = Item.createNew('text', 'category');
      expect(i.revision).toMatch(/^1-/);
      firstRevision = i.revision;
      i = i.setPosition(10);
      expect(i.getPosition()).toEqual(10);
      expect(i.revision).toMatch(/^2-/);
      secondRevision = i.revision;
      i = i.setText('text2');
      expect(i.getText()).toEqual('text2');
      expect(i.revision).toMatch(/^3-/);
      thirdRevision = i.revision;
      expect(firstRevision.slice(2)).not.toEqual(secondRevision.slice(2));
      expect(firstRevision.slice(2)).not.toEqual(thirdRevision.slice(2));
      expect(secondRevision.slice(2)).not.toEqual(thirdRevision.slice(2));
      return expect(i.revisions).toEqual([firstRevision, secondRevision]);
    });
    it('should encode and decode without changes', function() {
      var category, filename, i, j, position, resolution, text;
      text = 'Some text';
      category = 'Some category';
      position = 1.2;
      resolution = 23;
      i = Item.createNew(text, category);
      i = i.setPosition(position);
      i = i.setResolved(resolution);
      filename = i.id + '-' + i.revision;
      j = Item.createFromJSON(filename, i.jsonEncode());
      expect(j.getID()).toEqual(i.getID());
      expect(j.getCreated()).toEqual(i.getCreated());
      expect(j.getResolved()).toEqual(i.getResolved());
      expect(j.getText()).toEqual(i.getText());
      expect(j.getCategory()).toEqual(i.getCategory());
      expect(j.revision).toEqual(i.revision);
      return expect(j.revisions).toEqual(i.revisions);
    });
    it('should correctly compute the latest common ancestor', function() {
      var id, itemA, itemB, itemC, itemD, itemE, itemF, itemG;
      id = 'abc';
      itemA = new Item(id, '4-d', ['1-a', '2-b', '3-c']);
      itemB = new Item(id, '4-d2', ['1-a', '2-b', '3-F']);
      itemC = new Item(id, '5-d3', ['1-a', '2-b', '3-c', '4-d']);
      itemD = new Item(id, '3-F', ['1-a', '2-b']);
      itemE = new Item(id, '3-c', ['1-a', '2-b']);
      itemF = new Item(id, '5-d3', ['1-a', '2-X', '3-Y', '4-Z']);
      itemG = new Item(id, '2-d3', ['1-X']);
      expect(itemA.getLatestCommonAncestor(itemA)).toEqual('4-d');
      expect(itemA.getLatestCommonAncestor(itemB)).toEqual('2-b');
      expect(itemA.getLatestCommonAncestor(itemC)).toEqual('4-d');
      expect(itemA.getLatestCommonAncestor(itemD)).toEqual('2-b');
      expect(itemA.getLatestCommonAncestor(itemE)).toEqual('3-c');
      expect(itemA.getLatestCommonAncestor(itemF)).toEqual('1-a');
      return expect(itemA.getLatestCommonAncestor(itemG)).toEqual(null);
    });
    it('should correctly merge in case of no conflicts', function() {
      var id, item, itemA, itemB, itemC, itemC2, itemC3, itemD, itemE, merged, merged2, revs;
      id = 'abc';
      item = Item.createNew('text', 'category');
      itemA = item.setText('text2');
      itemB = item.setCategory('category2');
      merged = itemA.mergeWith(itemB, item);
      expect(merged.getText()).toEqual('text2');
      expect(merged.getCategory()).toEqual('category2');
      expect(merged.getResolved()).toBeFalsy();
      revs = merged.getRevisionsIncludingSelf();
      expect(revs).toContain(item.getRevision());
      expect(revs).toContain(itemA.getRevision());
      expect(revs).toContain(itemB.getRevision());
      expect(revs).toContain(merged.getRevision());
      expect(revs.length).toEqual(4);
      itemC = item.setResolved();
      merged = itemC.mergeWith(itemA, item);
      expect(merged.getText()).toEqual('text2');
      expect(merged.getCategory()).toEqual('category');
      expect(merged.getResolved()).toBeTruthy();
      expect(item.getResolved()).toBeFalsy();
      expect(itemA.getResolved()).toBeFalsy();
      itemC2 = merged.setText('abc');
      expect(itemC2.getResolved()).toEqual(merged.getResolved());
      itemC3 = merged.setCategory('def');
      merged = itemC2.mergeWith(itemC3, merged);
      expect(merged.getResolved()).toEqual(itemC2.getResolved());
      itemD = item.setPosition(20);
      merged = itemA.mergeWith(itemD, item);
      expect(merged.getPosition()).toEqual(20);
      itemE = merged.setPosition(21);
      merged2 = itemE.mergeWith(itemD, itemD);
      return expect(merged2.getPosition()).toEqual(21);
    });
    return it('should correctly merge in case of conflicts', function() {
      var item, itemA, itemB, merged;
      item = Item.createNew('text', 'category');
      itemA = item.setResolved();
      expect(itemA.getResolved()).toBeGreaterThan(0);
      itemB = item.setResolved();
      itemB.resolved = itemA.resolved + 10;
      merged = itemB.mergeWith(itemA, item);
      expect(merged.getResolved()).toEqual(itemA.getResolved());
      itemA = item.setText('a smallertext').setCategory('a smallercategory');
      itemB = item.setText('b largertext').setCategory('b largercategory');
      merged = itemB.mergeWith(itemA, item);
      expect(merged.getText()).toEqual('a smallertext, b largertext');
      expect(merged.getCategory()).toEqual('a smallercategory, b largercategory');
      itemA = item.setPosition(5);
      itemB = item.setPosition(7);
      merged = itemA.mergeWith(itemB, item);
      return expect(merged.getPosition()).toEqual(5);
    });
  });

  describe('Database with LocalStorageBackend', function() {
    var database;
    database = new Database(LocalStorageBackend, {
      context: 'synclist_test'
    });
    beforeEach(function() {
      LocalStorageBackend.clearContext('synclist_test');
      return database.clearObservers();
    });
    it('should list objects', function() {
      var objects;
      expect(database.listObjects()).toEqual([]);
      database.save('firstitem', 'data');
      expect(database.listObjects()).toEqual(['firstitem']);
      database.save('seconditem', 'data');
      objects = database.listObjects();
      objects.sort();
      return expect(objects).toEqual(['firstitem', 'seconditem']);
    });
    it('should load the same data it saved', function() {
      var data;
      data = 'abcdef';
      database.save('somefile', data);
      return expect(database.load('somefile')).toEqual(data);
    });
    it('should use the password', function() {
      var data, database2;
      database2 = new Database(LocalStorageBackend, {
        context: 'synclist_test'
      }, 'otherpassword');
      data = 'asoeuoecug';
      database.save('somefile2', data);
      return expect(database2.load('somefile2')).not.toEqual(data);
    });
    return it('should call change observers', function() {
      var callback;
      callback = jasmine.createSpy('onChange');
      database.onChange(callback);
      expect(callback).not.toHaveBeenCalled();
      database.save('callbacktestfile', 'euotu');
      expect(callback).toHaveBeenCalledWith('callbacktestfile');
      database.save('callbacktestfile2', 'euotu');
      return expect(callback).toHaveBeenCalledWith('callbacktestfile2');
    });
  });

  describe('Utilities', function() {
    it('should convert empty arrays to empty sets', function() {
      return expect(Utilities.arrayToSet([])).toEqual({});
    });
    it('should convert arrays to sets', function() {
      expect(Utilities.arrayToSet(['', '7', '4', '3'])).toEqual({
        '': 1,
        '7': 1,
        '4': 1,
        '3': 1
      });
      expect(Utilities.arrayToSet(['7', '4', '7', '3', '4'])).toEqual({
        '7': 1,
        '4': 1,
        '3': 1
      });
      return expect(Utilities.arrayToSet(['a', '4', '7', '3', '4'])).toEqual({
        'a': 1,
        '7': 1,
        '4': 1,
        '3': 1
      });
    });
    it('should convert arrays to sets and back to arrays', function() {
      var array;
      array = ['1', 'a', '7', 'b'];
      array.sort();
      return expect(Utilities.setToArray(Utilities.arrayToSet(array))).toEqual(array);
    });
    it('should convert arrays to sets and back to arrays, removing duplicates', function() {
      var array;
      array = ['1', 'a', '7', 'b', '7'];
      array.sort();
      return expect(Utilities.setToArray(Utilities.arrayToSet(array))).not.toEqual(array);
    });
    it('should sort arrays and remove duplicates', function() {
      var array;
      array = ['1', '8', '1', '', '', '3'];
      return expect(Utilities.sortedArrayWithoutDuplicates(array)).toEqual(['', '1', '3', '8']);
    });
    return it('should correctly compute the symmetric difference', function() {
      var array1, array2;
      array1 = ['e', 'g', 'a', 'b'];
      array2 = ['', 'b', 'g', ''];
      expect(Utilities.symmetricSortedArrayDifference(array1, array2)).toEqual(['', 'a', 'e']);
      expect(Utilities.symmetricSortedArrayDifference([], ['a'])).toEqual(['a']);
      return expect(Utilities.symmetricSortedArrayDifference(['a'], ['a', 'b'])).toEqual(['b']);
    });
  });

  describe('Manager', function() {
    var database, manager;
    database = new Database(LocalStorageBackend, {
      context: 'synclist_test'
    });
    manager = null;
    beforeEach(function() {
      LocalStorageBackend.clearContext('synclist_test');
      database.clearObservers();
      if (manager != null) {
        manager.clearObservers();
      }
      return manager = new Manager(database);
    });
    it('should save an item', function() {
      var id, item, items;
      manager.saveItem(Item.createNew('testData'));
      items = (function() {
        var _ref, _results;
        _ref = manager.getItems();
        _results = [];
        for (id in _ref) {
          item = _ref[id];
          _results.push(item);
        }
        return _results;
      })();
      return expect(items.length).toEqual(1);
    });
    it('should save a new revision', function() {
      var id, item, item2;
      item = manager.saveItem(Item.createNew('testData'));
      expect((function() {
        var _results;
        _results = [];
        for (id in manager.getItems()) {
          _results.push(id);
        }
        return _results;
      })()).toEqual([item.getID()]);
      item2 = manager.saveItem(item.setCategory('newCategory'));
      expect((function() {
        var _results;
        _results = [];
        for (id in manager.getItems()) {
          _results.push(id);
        }
        return _results;
      })()).toEqual([item.getID()]);
      return expect(manager.getItems()[item.getID()].getRevision()).toEqual(item2.getRevision());
    });
    it('should merge conflicts', function() {
      var id, item, item2, item3, revision;
      item = manager.saveItem(Item.createNew('testData'));
      id = item.getID();
      item2 = manager.saveItem(item.setCategory('newCategory'));
      expect(manager.getItems()[id].getRevision()).toEqual(item2.getRevision());
      item3 = manager.saveItem(item.setText('newText'));
      revision = manager.getItems()[id].getRevision();
      expect(revision).not.toEqual(item3.getRevision());
      expect(revision).not.toEqual(item2.getRevision());
      return expect(revision).toMatch(/^3-/);
    });
    return it('should notify observers', function() {
      var callback, item;
      callback = jasmine.createSpy('onChange');
      manager.onChange(callback);
      expect(callback).not.toHaveBeenCalled();
      item = Item.createNew('testData');
      manager.saveItem(item);
      return expect(callback).toHaveBeenCalledWith(item);
    });
  });

}).call(this);
