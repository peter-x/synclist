// Generated by CoffeeScript 1.6.1
(function() {

  describe('Item', function() {
    it('should not create an item from corrupt JSON string', function() {
      return expect(Item.createFromJSON('1-abcdef01234', '{')).toBeNull();
    });
    it('should create an item from correct JSON string', function() {
      var data, i;
      data = '{"revisions":[],"creation":1382207794.2,"resolution":0,' + '"modification":1382207794,"category":"Some category",' + '"text":"Some text","position":1.2}';
      i = Item.createFromJSON('someid-1-abcdef01234', data);
      expect(i.getID()).toEqual('someid');
      expect(i.revision).toMatch(/^1-abcdef01234$/);
      expect(i.getCreated()).toEqual(1382207794.2);
      expect(i.isResolved()).toEqual(false);
      expect(i.getCategory()).toEqual('Some category');
      expect(i.getText()).toEqual('Some text');
      return expect(i.getPosition()).toEqual(1.2);
    });
    it('should create a new item', function() {
      var category, i, text;
      text = 'Example Text';
      category = 'Example Category';
      i = Item.createNew(text, category);
      expect(i.getID().length).toBeGreaterThan(0);
      expect(i.getCreated()).toBeGreaterThan(0);
      expect(i.getResolved()).toEqual(0);
      expect(i.getText()).toEqual(text);
      expect(i.getCategory()).toEqual(category);
      return expect(i.revision).toMatch(/^1-/);
    });
    it('should increase revision numbers on change and store revisions', function() {
      var firstRevision, i, secondRevision, thirdRevision;
      i = Item.createNew('text', 'category');
      expect(i.revision).toMatch(/^1-/);
      firstRevision = i.revision;
      i = i.setPosition(10);
      expect(i.getPosition()).toEqual(10);
      expect(i.revision).toMatch(/^2-/);
      secondRevision = i.revision;
      i = i.setText('text2');
      expect(i.getText()).toEqual('text2');
      expect(i.revision).toMatch(/^3-/);
      thirdRevision = i.revision;
      expect(firstRevision.slice(2)).not.toEqual(secondRevision.slice(2));
      expect(firstRevision.slice(2)).not.toEqual(thirdRevision.slice(2));
      expect(secondRevision.slice(2)).not.toEqual(thirdRevision.slice(2));
      return expect(i.revisions).toEqual([firstRevision, secondRevision]);
    });
    it('should encode and decode without changes', function() {
      var category, filename, i, j, position, resolution, text;
      text = 'Some text';
      category = 'Some category';
      position = 1.2;
      resolution = 23;
      i = Item.createNew(text, category);
      i = i.setPosition(position);
      i = i.setResolved(resolution);
      filename = i.id + '-' + i.revision;
      j = Item.createFromJSON(filename, i.jsonEncode());
      expect(j.getID()).toEqual(i.getID());
      expect(j.getCreated()).toEqual(i.getCreated());
      expect(j.getResolved()).toEqual(i.getResolved());
      expect(j.getText()).toEqual(i.getText());
      expect(j.getCategory()).toEqual(i.getCategory());
      expect(j.revision).toEqual(i.revision);
      return expect(j.revisions).toEqual(i.revisions);
    });
    it('should correctly compute the latest common ancestor', function() {
      var id, itemA, itemB, itemC, itemD, itemE, itemF, itemG;
      id = 'abc';
      itemA = new Item(id, '4-d', ['1-a', '2-b', '3-c']);
      itemB = new Item(id, '4-d2', ['1-a', '2-b', '3-F']);
      itemC = new Item(id, '5-d3', ['1-a', '2-b', '3-c', '4-d']);
      itemD = new Item(id, '3-F', ['1-a', '2-b']);
      itemE = new Item(id, '3-c', ['1-a', '2-b']);
      itemF = new Item(id, '5-d3', ['1-a', '2-X', '3-Y', '4-Z']);
      itemG = new Item(id, '2-d3', ['1-X']);
      expect(itemA.getLatestCommonAncestor(itemA)).toEqual('4-d');
      expect(itemA.getLatestCommonAncestor(itemB)).toEqual('2-b');
      expect(itemA.getLatestCommonAncestor(itemC)).toEqual('4-d');
      expect(itemA.getLatestCommonAncestor(itemD)).toEqual('2-b');
      expect(itemA.getLatestCommonAncestor(itemE)).toEqual('3-c');
      expect(itemA.getLatestCommonAncestor(itemF)).toEqual('1-a');
      return expect(itemA.getLatestCommonAncestor(itemG)).toEqual(null);
    });
    it('should correctly merge in case of no conflicts', function() {
      var id, item, itemA, itemB, itemC, itemC2, itemC3, itemD, itemE, merged, merged2, revs;
      id = 'abc';
      item = Item.createNew('text', 'category');
      itemA = item.setText('text2');
      itemB = item.setCategory('category2');
      merged = itemA.mergeWith(itemB, item);
      expect(merged.getText()).toEqual('text2');
      expect(merged.getCategory()).toEqual('category2');
      expect(merged.getResolved()).toBeFalsy();
      revs = merged.getRevisionsIncludingSelf();
      expect(revs).toContain(item.getRevision());
      expect(revs).toContain(itemA.getRevision());
      expect(revs).toContain(itemB.getRevision());
      expect(revs).toContain(merged.getRevision());
      expect(revs.length).toEqual(4);
      itemC = item.setResolved();
      merged = itemC.mergeWith(itemA, item);
      expect(merged.getText()).toEqual('text2');
      expect(merged.getCategory()).toEqual('category');
      expect(merged.getResolved()).toBeTruthy();
      expect(item.getResolved()).toBeFalsy();
      expect(itemA.getResolved()).toBeFalsy();
      itemC2 = merged.setText('abc');
      expect(itemC2.getResolved()).toEqual(merged.getResolved());
      itemC3 = merged.setCategory('def');
      merged = itemC2.mergeWith(itemC3, merged);
      expect(merged.getResolved()).toEqual(itemC2.getResolved());
      itemD = item.setPosition(20);
      merged = itemA.mergeWith(itemD, item);
      expect(merged.getPosition()).toEqual(20);
      itemE = merged.setPosition(21);
      merged2 = itemE.mergeWith(itemD, itemD);
      return expect(merged2.getPosition()).toEqual(21);
    });
    return it('should correctly merge in case of conflicts', function() {
      var item, itemA, itemB, merged;
      item = Item.createNew('text', 'category');
      itemA = item.setResolved();
      expect(itemA.getResolved()).toBeGreaterThan(0);
      itemB = item.setResolved();
      itemB.resolved = itemA.resolved + 10;
      merged = itemB.mergeWith(itemA, item);
      expect(merged.getResolved()).toEqual(itemA.getResolved());
      itemA = item.setText('a smallertext').setCategory('a smallercategory');
      itemB = item.setText('b largertext').setCategory('b largercategory');
      merged = itemB.mergeWith(itemA, item);
      expect(merged.getText()).toEqual('a smallertext, b largertext');
      expect(merged.getCategory()).toEqual('a smallercategory, b largercategory');
      itemA = item.setPosition(5);
      itemB = item.setPosition(7);
      merged = itemA.mergeWith(itemB, item);
      return expect(merged.getPosition()).toEqual(5);
    });
  });

  describe('Database with LocalStorageBackend', function() {
    var database, failure, success;
    database = new Database(LocalStorageBackend, {
      context: 'synclist_test'
    });
    failure = jasmine.createSpy('failure');
    success = jasmine.createSpy('success');
    beforeEach(function() {
      success.callCount = 0;
      failure.callCount = 0;
      LocalStorageBackend.clearContext('synclist_test');
      return database.clearObservers();
    });
    it('should list objects', function() {
      database.listObjects().fail(failure).then(function(objects) {
        expect(objects).toEqual([]);
        return success();
      });
      database.save('firstitem', 'data').fail(failure);
      database.listObjects().fail(failure).then(function(objects) {
        expect(objects).toEqual(['firstitem']);
        return success();
      });
      database.save('seconditem', 'data').fail(failure);
      database.listObjects().fail(failure).then(function(objects) {
        objects.sort();
        expect(objects).toEqual(['firstitem', 'seconditem']);
        return success();
      });
      expect(success.callCount).toEqual(3);
      return expect(failure).not.toHaveBeenCalled();
    });
    it('should load the same data it saved', function() {
      var data;
      data = 'abcdef';
      database.save('somefile', data).fail(failure);
      database.load('somefile').fail(failure).then(function(returnedData) {
        expect(returnedData).toEqual(data);
        return success();
      });
      expect(success.callCount).toEqual(1);
      return expect(failure).not.toHaveBeenCalled();
    });
    it('should use the password', function() {
      var data, database2;
      database2 = new Database(LocalStorageBackend, {
        context: 'synclist_test'
      }, 'otherpassword');
      data = 'asoeuoecug';
      database.save('somefile2', data);
      return database2.load('somefile2').fail(function() {
        return expect(true).toBeFalsy().then(function(returnedData) {
          expect(true).toBeFalsy();
          return expect(returnedData).not.toEqual(data);
        });
      });
    });
    return it('should call change observers', function() {
      var callback;
      callback = jasmine.createSpy('observe');
      database.observe(callback);
      expect(callback).not.toHaveBeenCalled();
      database.save('callbacktestfile', 'euotu');
      expect(callback).toHaveBeenCalledWith('callbacktestfile');
      database.save('callbacktestfile2', 'euotu');
      return expect(callback).toHaveBeenCalledWith('callbacktestfile2');
    });
  });

  describe('Utilities', function() {
    it('should convert empty arrays to empty sets', function() {
      return expect(Utilities.arrayToSet([])).toEqual({});
    });
    it('should convert arrays to sets', function() {
      expect(Utilities.arrayToSet(['', '7', '4', '3'])).toEqual({
        '': 1,
        '7': 1,
        '4': 1,
        '3': 1
      });
      expect(Utilities.arrayToSet(['7', '4', '7', '3', '4'])).toEqual({
        '7': 1,
        '4': 1,
        '3': 1
      });
      return expect(Utilities.arrayToSet(['a', '4', '7', '3', '4'])).toEqual({
        'a': 1,
        '7': 1,
        '4': 1,
        '3': 1
      });
    });
    it('should convert arrays to sets and back to arrays', function() {
      var array;
      array = ['1', 'a', '7', 'b'];
      array.sort();
      return expect(Utilities.setToArray(Utilities.arrayToSet(array))).toEqual(array);
    });
    it('should convert arrays to sets and back to arrays, removing duplicates', function() {
      var array;
      array = ['1', 'a', '7', 'b', '7'];
      array.sort();
      return expect(Utilities.setToArray(Utilities.arrayToSet(array))).not.toEqual(array);
    });
    it('should sort arrays and remove duplicates', function() {
      var array;
      array = ['1', '8', '1', '', '', '3'];
      return expect(Utilities.sortedArrayWithoutDuplicates(array)).toEqual(['', '1', '3', '8']);
    });
    return it('should correctly compute the symmetric difference', function() {
      var array1, array2;
      array1 = ['e', 'g', 'a', 'b'];
      array2 = ['', 'b', 'g', ''];
      expect(Utilities.symmetricSortedArrayDifference(array1, array2)).toEqual(['', 'a', 'e']);
      expect(Utilities.symmetricSortedArrayDifference([], ['a'])).toEqual(['a']);
      return expect(Utilities.symmetricSortedArrayDifference(['a'], ['a', 'b'])).toEqual(['b']);
    });
  });

  describe('Manager', function() {
    var database, failure, manager, success;
    database = new Database(LocalStorageBackend, {
      context: 'synclist_test'
    });
    manager = null;
    failure = jasmine.createSpy('failure');
    success = jasmine.createSpy('success');
    beforeEach(function() {
      success.callCount = 0;
      failure.callCount = 0;
      LocalStorageBackend.clearContext('synclist_test');
      database.clearObservers();
      if (manager != null) {
        manager.clearObservers();
      }
      return manager = new Manager(database);
    });
    it('should save an item', function() {
      manager.saveItem(Item.createNew('testData')).fail(failure).then(function() {
        var id, item, items;
        items = (function() {
          var _ref, _results;
          _ref = manager.getItems();
          _results = [];
          for (id in _ref) {
            item = _ref[id];
            _results.push(item);
          }
          return _results;
        })();
        expect(items.length).toEqual(1);
        return success();
      });
      expect(success.callCount).toEqual(1);
      return expect(failure).not.toHaveBeenCalled();
    });
    it('should save a new revision', function() {
      var id, item, item2;
      item = Item.createNew('testData');
      manager.saveItem(item).fail(failure).then(function() {
        var id;
        expect((function() {
          var _results;
          _results = [];
          for (id in manager.getItems()) {
            _results.push(id);
          }
          return _results;
        })()).toEqual([item.getID()]);
        return success();
      });
      item2 = item.setCategory('newCategory');
      manager.saveItem(item2).fail(failure).then(success);
      expect((function() {
        var _results;
        _results = [];
        for (id in manager.getItems()) {
          _results.push(id);
        }
        return _results;
      })()).toEqual([item.getID()]);
      expect(manager.getItems()[item.getID()].getRevision()).toEqual(item2.getRevision());
      expect(success.callCount).toEqual(2);
      return expect(failure).not.toHaveBeenCalled();
    });
    it('should merge conflicts', function() {
      var id, item, item2, item3, revision;
      item = Item.createNew('testData');
      manager.saveItem(item).fail(failure).then(success);
      id = item.getID();
      item2 = item.setCategory('newCategory');
      manager.saveItem(item2).fail(failure).then(success);
      expect(manager.getItems()[id].getRevision()).toEqual(item2.getRevision());
      item3 = item.setText('newText');
      manager.saveItem(item3).fail(failure).then(success);
      revision = manager.getItems()[id].getRevision();
      expect(revision).not.toEqual(item3.getRevision());
      expect(revision).not.toEqual(item2.getRevision());
      expect(revision).toMatch(/^3-/);
      expect(success.callCount).toEqual(3);
      return expect(failure).not.toHaveBeenCalled();
    });
    return it('should notify observers', function() {
      var callback, item;
      callback = jasmine.createSpy('observe');
      manager.observe(callback);
      expect(callback).not.toHaveBeenCalled();
      item = Item.createNew('testData');
      manager.saveItem(item);
      return expect(callback).toHaveBeenCalledWith(item);
    });
  });

  describe('SyncService', function() {
    var MockSettings, database1, database2, failure, mockSettings, settingsChanged, success;
    settingsChanged = null;
    MockSettings = (function() {

      function MockSettings() {}

      MockSettings.prototype.observe = function(callback) {
        return settingsChanged = callback;
      };

      return MockSettings;

    })();
    mockSettings = new MockSettings();
    database1 = new Database(LocalStorageBackend, {
      context: 'synclist_test1'
    }, 'password1');
    database2 = new Database(LocalStorageBackend, {
      context: 'synclist_test2'
    }, 'password2');
    failure = jasmine.createSpy('failure');
    success = jasmine.createSpy('success');
    beforeEach(function() {
      success.callCount = 0;
      failure.callCount = 0;
      if (settingsChanged) {
        settingsChanged([]);
      }
      LocalStorageBackend.clearContext('synclist_test1');
      LocalStorageBackend.clearContext('synclist_test2');
      database1.clearObservers();
      return database2.clearObservers();
    });
    it('should synchronize incrementally', function() {
      var syncService;
      syncService = new SyncService(mockSettings, database1);
      settingsChanged([
        {
          type: 'LocalStorage',
          location: 'synclist_test2',
          encpassword: 'password2'
        }
      ]);
      database1.save('item_test', 'data').then(success, failure);
      database2.load('item_test').fail(failure).then(function(data) {
        expect(data).toEqual('data');
        return success();
      });
      expect(success.callCount).toEqual(2);
      return expect(failure).not.toHaveBeenCalled();
    });
    it('should synchronize on startup', function() {
      var syncService;
      syncService = new SyncService(mockSettings, database1);
      database1.save('item_test2', 'data2').then(success, failure);
      database1.save('item_test3', 'data3').then(success, failure);
      database2.save('item_test4', 'data4').then(success, failure);
      settingsChanged([
        {
          type: 'LocalStorage',
          location: 'synclist_test2',
          encpassword: 'password2'
        }
      ]);
      database2.load('item_test2').fail(failure).then(function(data) {
        expect(data).toEqual('data2');
        return success();
      });
      database2.load('item_test3').fail(failure).then(function(data) {
        expect(data).toEqual('data3');
        return success();
      });
      database1.load('item_test4').fail(failure).then(function(data) {
        expect(data).toEqual('data4');
        return success();
      });
      expect(success.callCount).toEqual(6);
      return expect(failure).not.toHaveBeenCalled();
    });
    return it('should synchronize three databases', function() {
      var database3, syncService;
      database3 = new Database(LocalStorageBackend, {
        context: 'synclist_test3'
      }, 'password3');
      syncService = new SyncService(mockSettings, database1);
      database3.save('item_test3', 'data3').then(success, failure);
      database3.save('item_test1', 'data1').then(success, failure);
      database2.save('item_test2', 'data2').then(success, failure);
      database2.save('item_test1', 'data1').then(success, failure);
      settingsChanged([
        {
          type: 'LocalStorage',
          location: 'synclist_test2',
          encpassword: 'password2'
        }, {
          type: 'LocalStorage',
          location: 'synclist_test3',
          encpassword: 'password3'
        }
      ]);
      database2.load('item_test3').fail(failure).then(function(data) {
        expect(data).toEqual('data3');
        return success();
      });
      database3.load('item_test2').fail(failure).then(function(data) {
        expect(data).toEqual('data2');
        return success();
      });
      database1.load('item_test1').fail(failure).then(function(data) {
        expect(data).toEqual('data1');
        return success();
      });
      expect(success.callCount).toEqual(7);
      return expect(failure).not.toHaveBeenCalled();
    });
  });

}).call(this);
